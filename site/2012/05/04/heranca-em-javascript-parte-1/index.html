<!doctype html>
<html lang="pt-BR">
<head>
	<meta charset="UTF-8" />
	
		<title>Herança em JavaScript parte I – Loop Infinito</title>
	
	
		<meta name="author" content="Caio Gondim" />
	
	
		<meta name="keywords" content="javascript, js, web development, desenvolvimento web, html5, front-end, programação, oop, orientação a objetos, herança, orientação a protótipos, java" />
	
	
		<meta name="description" content="Uma das coisas que mais assusta programadores vindos de linguagens orientadas a objeto, como Java e C++, é a falta de classes em JavaScript. Muitos, inclusive, tentam simular este comportamento no JavaScript, mas poucos conseguem com sucesso. Neste post numa série de 2, iremos relembrar o que é herança, a cadeia de protótipos e como era feito a herança em JavaScript." />
	
	<meta name="language" content="pt" />
	<meta name="content-language" content="pt-BR" />
	<meta name="robots" content="all" />
	<meta name="distribution" content="Global" />
	<meta name="resource-type" content="document" />
	
	<link rel="icon" type="image/png" href="/images/favicon.png" />
	<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/l8p" title="Loop Infinito: Web na Crista da Onda" />
	<link rel="stylesheet" type="text/css" href="/styles/blog.css" media="all" />
	<link rel="stylesheet" type="text/css" href="/styles/twilight.css" media="all" />
	
	
		<link rel="stylesheet" type="text/css" href="/styles/code.html.css" media="all" />
	
	
	<script type="text/javascript" src="/scripts/jquery.min.js"></script>
	<script type="text/javascript" src="/scripts/rainbow-custom.min.js"></script>	
	<script type="text/javascript">
	
	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-30127419-1']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>
</head>
<body>
	<div id="wrapper">
		<header id="main">
			<h1><a href="/" id="logo">Loop Infinito</a></h1>
			<nav>
				<ul>
					<li><a href="/">Posts</a></li>
					<li><a href="/projetos">Projetos</a></li>
					<li><a href="/sobre">Sobre</a></li>
					<li><input type="search" placeholder="Busca"></li>
				</ul>
			</nav>
		</header>

		<section id="content">

			<section class="post-container" itemscope itemtype="http://schema.org/BlogPosting">
				<span class="hidden" itemprop="publisher">Loop Infinito</span>
				<aside class="post-meta">
					<ul>
						<li class="post-data">
							<time itemprop="datePublished" datetime="2012-05-04">04/05/2012</time>
						</li>
						<li class="post-autor">
							<a href="http://twitter.com/caio_gondim" title="Caio Gondim" alt="Caio Gondim" rel="author" itemprop="author">Caio Gondim</a>
						</li>
						
							<li class="post-comentarios"><a href="/2012/05/04/heranca-em-javascript-parte-1/#disqus_thread" data-disqus-identifier="/2012/05/04/heranca-em-javascript-parte-1" itemprop="interactionCount">Carregando...</a></li>
						
						
						<li class="post-tags">
							<ul>
								
								<li><a href="/tag/javascript"><span>#</span>javascript</a></li>
													
							</ul>
							
								<span class="hidden" itemprop="keywords">javascript, js, web development, desenvolvimento web, html5, front-end, programação, oop, orientação a objetos, herança, orientação a protótipos, java</span>
							
						</li>
						
					</ul>	
				</aside>
				<article>
					<header>
						<h1><a href="/2012/05/04/heranca-em-javascript-parte-1/" itemprop="headline">Herança em JavaScript <span class="light">parte I</span></a></h1>
					</header>
					<section itemprop="articleBody">
						<p><img alt='' src='/images/posts/2012-05-04-heranca-em-javascript.jpg' /></p>
<p>Diferente das linguagens mais conhecidas, como Java ou C++ que utilizam a orientação a objetos clássica, JavaScript utiliza uma abordagem diferente para compartilhar código entre entidades, chamada de orientação a protótipo. Mas antes de entrarmos em detalhes, vamos primeiro relembrar o que é a herança clássica nas linguagens orientadas a objetos.</p>

<h2 id='herana_clssica'>Herança clássica</h2>

<p>Herança em OOP é a capacidade de classes <strong>compartilharem</strong> atributos e métodos entre si. Geralmente a herança é usada para compartilhar comportamentos generalizados e comuns entres as classes filhas.</p>

<h3 id='show_me_the_code'>Show me the code</h3>

<p>Imaginem que temos que representar em nossa aplicação alguns animais, como gato e cachorro. Com herança podemos definir comportamentos comuns entre eles apenas uma vez, como respirar, nascer e morrer, e reutilizar estes métodos já implementados apenas os herdando nas classes filhas.</p>

<p>Vamos implementar o cenário acima em Java. Como desejamos representar gatos e cachorros, e sabemos que eles possuem métodos similares, como nascer, morrer e respirar, vamos criar uma classe Animal e implementar estes métodos nela, para que gatos e cachorros possam herdá-los.</p>
<pre><code data-language='java'>
// setamos a classe como abstrata pois não desejamos criar
// objetos do tipo animal, apenas os tipos mais
// especializados como Gato ou Cachorro podem ser instânciados
public abstract class Animal {
  public void nascer() {
    ...
  }

  public void morrer() {
    ...
  }

  public void respirar() {
    ...
  }
}
</code></pre>
<p>Agora definimos as classes Gato e Cachorro, que irão herdar de Animal e implementar métodos que só fazem sentido em seu próprio escopo, como miar no caso de Gato e latir no caso de Cachorro.</p>
<pre><code data-language='javascript'>
// além do método miar, os objetos do tipo Gato 
// terão também, devido a herança, os métodos de Animal
class Gato extends Animal {
  public void miar() {
    ...
  }

  // construtor
  public Gato() {
    ...
  }
}

// com os objetos do tipo Cachorro acontece o mesmo
// além do método latir, definido explicitamente na classe
// ele irá herdar os métodos nascer, morrer e respirar
class Cachorro extends Animal {
  public void latir() {
    ..
  }

  // construtor
  public Cachorro() {
    ...
  }
}
</code></pre>
<p>Definimos a relação de herança com a palavra reservada <code>extends</code>. Com isso as classes Gato e Cachorro irão possuir, além de seus próprios métodos, os métodos herdados de Animal, como nascer, morrer e respirar.</p>

<p>Então fica claro que com herança conseguimos um enorme reuso de código. De outra forma, teríamos que redefinir métodos e atributos comuns em todas as classes, tornando a manutenção do código mais complexa e propensa a erros.</p>

<h2 id='cadeia_de_prottipos'>Cadeia de protótipos</h2>

<p>Em JavaScript (quase) tudo é um objeto, não existem classes. Até mesmo as <code>function</code> são objetos. Se quisermos herdar os métodos e atributos de um objeto, o utilizamos como protótipo do novo objeto a ser criado. Mesmo que não esteja definido explicitamente no código, todos os outros objetos de JavaScript, com a exceção do objeto <code>Object</code>, utilizam um outro objeto como protótipo.</p>

<p>Como no exemplo abaixo, definimos um objeto vazio, um array vazio e uma função. Eles todos herdarão métodos e atributos de seus protótipos.</p>
<pre><code data-language='javascript'>
// aqui criamos um novo objeto genérico com o nome carro
// ele automaticamente usará o prototipo de Object
var carro = {}
carro.modelo = 'Celta'
carro.marca = 'Chevrolet'
carro.hasOwnProperty('modelo') // método herdado de Object
Object.getPrototypeOf(carro) // retorna Object

// frutas herdará as propriedades de Array
var frutas = [ 'morango', 'manga', 'laranja' ]
frutas.reverse() // método herdado de Array
frutas.hasOwnProperty('length') // método herdado de Object
Object.getPrototypeOf(frutas) // retorna []
Object.getPrototypeOf(Object.getPrototypeOf(frutas)) // retorna Object

// validarCPF irá herdar propriedades de Function
function validarCPF() {
  ...
  return true
}
// aqui vemos uma função se comportando como um objeto
validarCPF.call() // método herdado de Function
Object.getPrototypeOf(validarCPF) // retorna function Empty() {}

</code></pre>
<p>É interessante notar que a herança ocorre em <strong>toda</strong> a cadeia de protótipos. Como quando definimos um array: ele herda todas as propriedades de Array e de Object, uma vez que Array usa Object como protótipo. Podemos verificar isso chamando o protótipo do protótipo de frutas. O protótipo de frutas é Array, e o protótipo de Array é Object ou, o protótipo do protótipo de frutas é Object.</p>

<p>Quando chamamos a propriedade de um objeto, o interpretador/VM JavaScript primeiro procura esta propriedade dentro do objeto, caso não encontre procura em seu protótipo, caso não encontre novamente procura no protótipo do protótipo, e assim sucessivamente, percorrendo toda a cadeia de protótipos até alcançar um protótipo com valor <code>null</code>.</p>

<h2 id='herana_em_javascript_com_construtores'>Herança em JavaScript com construtores</h2>

<p>O método mais difundido e crossbrowser de criação de objetos e herança em JavaScript é através de funções que funcionam como construtores. Nesse método, definimos funções que irão se comportar como construtores em linguagens clássicas orientadas a objeto. Depois de definida a função, podemos instanciar objetos do tipo definido usando <code>new</code>.</p>

<p>Em JavaScript, uma função também é um objeto, e ela possui a propriedade <code>prototype</code>. Nesta propriedade definimos o prototipo da função, ou todas as propriedades que os objetos deste tipo irão ter se invocarmos <code>new</code>.</p>

<p>Ok, pode parecer complicado falando, mas fica bem fácil olhando o código.</p>
<pre><code data-language='javascript'>
// criamos o construtor Animal
function Animal() {
}
Animal.prototype.nascer = function() {
  ...
}
Animal.prototype.morrer = function() {
  ...
}
Animal.prototype.respirar = function() {
  ...
}
</code></pre>
<p>Agora definimos Gato e Cachorro, e usamos Animal como protótipo.</p>
<pre><code data-language='javascript'>
// criamos o construtor Gato
function Gato(nome) {
  this.nome = nome
}
Gato.prototype = new Animal() // definimos que Gato usa Animal como protótipo
Gato.prototype.constructor = Gato // para que não fique com o valor do construtor do objeto usado como protótipo
Gato.prototype.miar = function() { // método miar apenas para Gato
  ...
}

// criamos o construtor Cachorro
function Cachorro(nome) {
  this.nome = nome
}
Cachorro.prototype = new Animal() // definimos que Cachorro usa Animal como protótipo
Cachorro.prototype.constructor = Cachorro()
Cachorro.prototype.latir = function() {
  ...
}

var rex = new Cachorro('rex') // criamos um objeto do tipo Cachorro
rex.latir() // utilizando um método definido em Cachorro
rex.respirar() // utilizando um método herdado de Animal
rex.nome // retorna 'rex'
</code></pre>
<p>Precisamos criar um novo objeto do tipo Animal para setarmos como protótipo, pois caso contrário estariamos passando a referência para a função.</p>

<p>A propriedade <code>constructor</code> nos informa o construtor do objeto. Nós precisamos defini-la manualmente pois esta proprieda existe no objeto Animal que passamos por protótipo, então todos os objetos de Cachorro e Gato irão herdar a propriedade construtor com o setado valor como Animal. Esta propriedade pode ser útil caso seja preciso chamar um método de um dos objetos na cadeia de protótipos.</p>

<p>Podemos verificar que rex é de fato um cachorro perguntado se ele é uma instância de Cachorro.</p>
<pre><code data-language='javascript'>
rex instanceof Cachorro // retorna true
rex instanceof Animal // retorn true. Cachorro.prototype --> Animal
rex instanceof Object // retorna true. Cachorro.prototype --> Animal.prototype --> Object
rex instanceof Array // retorna false
</code></pre>
<p>Interessante notar que rex também é uma instância de Animal, já que Cachorro usa Animal como protótipo. E também é instância de Object, já que Animal usa, implicitamente, Object como protótipo.</p>

<p>Por ser uma linguagem orientada a protótipos, nós podemos definir um novo ao método ao protótipo e todos os objetos já instanciados irão ter acesso a este método criado, o que é impossível de ser feito em linguagens como Java (me corrijam se estiver falando besteira).</p>
<pre><code data-language='javascript'>
Cachorro.prototype.morder = function() {
  ...
}
rex.morder() // rex mesmo depois de instanciado terá acesso aos novos métodos definidos no protótipo de Cachorro
</code></pre>
<p>Um dos perigos dessa abordagem é que caso se esqueça de usar <code>new</code>, o <code>this</code> dentro da <code>function</code> irá se referenciar ao objeto global, e poderá sobreescrever algumas variáveis já declaradas antes.</p>

<p>Eu particularmente não sou a favor do uso do <code>new</code> pois ele torna ambíguo o uso de funções. Pois algumas funcionam como construtores e outras como funções normais. E sintaticamente o <code>new</code> pode ser usado em qualquer tipo de função.</p>

<h3 id='continua'>Continua&#8230;</h3>

<p>Este é o método padrão de herança em JavaScript. Grande parte desta bagunça é devido ao JavaScript ter sido lançado <strong>muito</strong> às pressas. Porém o ECMAscript, o grupo que padroniza o JavaScript, vem adicionado várias funções para tornar o trabalho com herança mais simples e finalmente abraçando a orientação a protótipo.</p>

<p>E é sobre este novo método de trabalhar com herança no ECMAscript 5 que iremos discutir na 2ª parte do post.</p>
<aside class='fonte'>
  <h3>Referência</h3>
  <ul>
    <li>
      <a href='https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain'>
        Mozilla Developer Network: Inheritance and the Prototype Chain
      </a>
    </li>
    <li><a href='http://stackoverflow.com/questions/2709612/using-object-create-instead-of-new'>StackOverflow: Using Object.create() instead of new</a></li>
    <li><a href='http://joost.zeekat.nl/constructors-considered-mildly-confusing.html'>code.h(oe)kje: Constructors considered mildly confusing</a></li>
  </ul>
</aside>				
					</section>
					
					<footer id="disqus_thread">
						<noscript>Por favor, habilite JavaScript para ver os comentários. <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
					</footer>
					
				</article>
			</section>

			
				<section id="disqus-power">
					<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
				</section>
			

		</section>

	</div>
	
		<script type="text/javascript">
		    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
		    var disqus_shortname = 'loopinfinito'; // required: replace example with your forum shortname
		    var disqus_identifier = '/2012/05/04/heranca-em-javascript-parte-1';
		    // var disqus_developer = 1;

		    // callback do Disqus
		    function disqus_callback() {
		    	// modifica o título da caixa de comentários
		    	$('#dsq-reply h3').html('Comentários')

		    	//
		    	// $('#dsq-comments').find('span.dsq-like-thumb').css({ position: 'relative', bottom: '5px' })
		    }

		    /* * * DON'T EDIT BELOW THIS LINE * * */
		    (function() {
		        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

		        // comment count
		        var s = document.createElement('script'); s.async = true;
		        s.type = 'text/javascript';
		        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
		        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
		    })();
		</script>
	
</body>
</html>